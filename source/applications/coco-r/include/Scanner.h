/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#pragma once

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <string>
#include "coco.h"

// io.h and fcntl are used to ensure binary read from streams on windows
#if _MSC_VER >= 1300
#include <io.h>
#include <fcntl.h>
#endif

#define COCO_WCHAR_MAX 65535
#define COCO_MIN_BUFFER_LENGTH 1024
#define COCO_MAX_BUFFER_LENGTH (64*COCO_MIN_BUFFER_LENGTH)
#define COCO_HEAP_BLOCK_SIZE (64*1024)
#define COCO_CPP_NAMESPACE_SEPARATOR L':'

namespace Coco
{

class Token  
{
public:
	int    kind;   // token kind
	size_t pos;    // token position in bytes in the source text (starting at 0)
	size_t charPos;// token position in characters in the source text (starting at 0)
	size_t col;    // token column (starting at 1)
	size_t line;   // token line (starting at 1)
	wchar_t * val; // token value
	Token *next;   // ML 2005-03-11 Peek tokens are kept in linked list

	Token();
	~Token();
};

class Buffer
{
// This Buffer supports the following cases:
// 1) seekable stream (file)
//    a) whole stream in buffer
//    b) part of stream in buffer
// 2) non seekable stream (network, console)
private:
	unsigned char *buf; // input buffer
	size_t bufCapacity;    // capacity of buf
	size_t bufStart;       // position of first byte in buffer relative to input stream
	size_t bufLen;         // length of buffer
	size_t fileLen;        // length of input stream (may change if the stream is no file)
	size_t bufPos;         // current position in buffer
	FILE* stream;       // input stream (seekable)
	bool isUserStream;  // was the stream opened by the user?
	
	size_t ReadNextStreamChunk();
	bool CanSeek();     // true if stream can be seeked otherwise false
	
public:
	static const int EoF = COCO_WCHAR_MAX + 1;

	Buffer(FILE* s, bool isUserStream);
	Buffer(unsigned char const * buf, size_t len);
	Buffer(Buffer *b);
	virtual ~Buffer();
	
	virtual void Close();
	virtual int Read();
	virtual int Peek();
	virtual std::wstring GetString(size_t beg, size_t end);
	virtual size_t GetPos();
	virtual void SetPos(size_t value);
};

class UTF8Buffer : public Buffer
{
public:
	UTF8Buffer(Buffer *b) : Buffer(b) {};
	virtual int Read();
};

//-----------------------------------------------------------------------------------
// StartStates  -- maps characters to start states of tokens
//-----------------------------------------------------------------------------------
class StartStates
{
private:
	class Elem
    {
	public:
		int key, val;
		Elem *next;
		Elem(int key, int val) { this->key = key; this->val = val; next = nullptr; }
	};

	Elem **tab;

public:
	StartStates() { tab = new Elem*[128]; memset(tab, 0, 128 * sizeof(Elem*)); }
	virtual ~StartStates()
    {
		for (int i = 0; i < 128; ++i)
        {
			Elem *e = tab[i];
			while (e != nullptr)
            {
				Elem *next = e->next;
				delete e;
				e = next;
			}
		}
		delete [] tab;
	}

	void set(int key, int val)
    {
		Elem *e = new Elem(key, val);
		int k = ((unsigned int) key) % 128;
		e->next = tab[k]; tab[k] = e;
	}

	int state(int key)
    {
		Elem *e = tab[((unsigned int) key) % 128];
		while (e != nullptr && e->key != key) e = e->next;
		return e == nullptr ? 0 : e->val;
	}
};

//-------------------------------------------------------------------------------------------
// KeywordMap  -- maps strings to integers (identifiers to keyword kinds)
//-------------------------------------------------------------------------------------------
class KeywordMap
{
private:
	class Elem
    {
	public:
		std::wstring key;
		int val;
		Elem *next;
		Elem(std::wstring const & key, int val) { this->key = key; this->val = val; next = nullptr; }
	};

	Elem **tab;

public:
	KeywordMap() { tab = new Elem*[128]; memset(tab, 0, 128 * sizeof(Elem*)); }
	virtual ~KeywordMap()
    {
		for (int i = 0; i < 128; ++i)
        {
			Elem *e = tab[i];
			while (e != nullptr)
            {
				Elem *next = e->next;
				delete e;
				e = next;
			}
		}
		delete [] tab;
	}

	void set(const wchar_t *key, int val)
    {
		Elem *e = new Elem(key, val);
		int k = String::Hash(key) % 128;
		e->next = tab[k]; tab[k] = e;
	}

	int get(std::wstring const & key, int defaultVal)
    {
		Elem *e = tab[String::Hash(key) % 128];
		while (e != nullptr && !String::Equal(e->key, key)) e = e->next;
		return e == nullptr ? defaultVal : e->val;
	}
};

class Scanner
{
private:
	void *firstHeap;
	void *heap;
	void *heapTop;
	void **heapEnd;

	unsigned char EOL;
	int eofSym;
	int noSym;
	int maxT;
	int charSetSize;
	StartStates start;
	KeywordMap keywords;

	Token *t;         // current token
	wchar_t *tval;    // text of current token
	int tvalLength;   // length of text of current token
	size_t tlen;         // length of current token

	Token *tokens;    // list of tokens already peeked (first token is a dummy)
	Token *pt;        // current peek token

	int ch;           // current input character

	size_t pos;        // byte position of current character
	size_t charPos;      // position by unicode characters starting with 0
	size_t line;         // line number of current character
	size_t col;          // column number of current character
	size_t oldEols;      // EOLs that appeared in a comment;

	void CreateHeapBlock();
	Token* CreateToken();
	void AppendVal(Token *t);
	void SetScannerBehindT();

	void Init();
	void NextCh();
	void AddCh();
	bool Comment0();
	bool Comment1();

	Token* NextToken();

public:
	Buffer *buffer;   // scanner buffer
	
	Scanner(unsigned char const * buf, size_t len);
	Scanner(std::string const & fileName);
	Scanner(FILE* s);
	~Scanner();
	Token* Scan();
	Token* Peek();
	void ResetPeek();

}; // end Scanner

} // namespace Coco

