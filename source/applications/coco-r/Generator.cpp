/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

#include "Generator.h"
#include "Scanner.h"
#include "coco.h"
#include "core/String.h"

namespace Coco
{

Generator::Generator(Tab *tab, Errors *errors)
{
	this->errors = errors;
	this->tab = tab;
	fram = nullptr;
	gen = nullptr;
	frameFile = nullptr;
}

FILE* Generator::OpenFrame(std::wstring const & frame)
{
	if (tab->frameDir.length() != 0)
    {
		frameFile = String::CreateAppend(tab->frameDir, L"/");
		String::Merge(frameFile, frame);
		std::string chFrameFile = Core::String::ToString(frameFile);
		fram = fopen(chFrameFile.c_str(), "r");
	}
	if (fram == nullptr)
    {
		frameFile = String::CreateAppend(tab->srcDir, frame);  /* pdt */
		std::string chFrameFile = Core::String::ToString(frameFile);
		fram = fopen(chFrameFile.c_str(), "r");
	}
	if (fram == nullptr)
    {
		std::wstring message = String::CreateAppend(L"-- Cannot find : ", frame);
		errors->Exception(message);
	}

	return fram;
}


FILE* Generator::OpenGen(std::wstring const & genName)
{ /* pdt */
	std::wstring fn = String::CreateAppend(tab->outDir, genName); /* pdt */
	std::string chFn = Core::String::ToString(fn);

	if ((gen = fopen(chFn.c_str(), "r")) != nullptr)
    {
		fclose(gen);
		std::wstring oldName = String::CreateAppend(fn, L".old");
    	std::string chOldName = Core::String::ToString(oldName);
		remove(chOldName.c_str()); 
        rename(chFn.c_str(), chOldName.c_str()); // copy with overwrite
	}
	if ((gen = fopen(chFn.c_str(), "w")) == nullptr)
    {
		std::wstring message = String::CreateAppend(L"-- Cannot generate : ", genName);
		errors->Exception(message);
	}

	return gen;
}


void Generator::GenCopyright()
{
	FILE *file = nullptr;

	if (!tab->frameDir.empty())
    {
		std::wstring copyFr = String::CreateAppend(tab->frameDir, L"/Copyright.frame");
		std::string chCopyFr = Core::String::ToString(copyFr);
		file = fopen(chCopyFr.c_str(), "r");
	}
	if (file == nullptr)
    {
		std::wstring copyFr = String::CreateAppend(tab->srcDir, L"Copyright.frame");
		std::string chCopyFr = Core::String::ToString(copyFr);
		file = fopen(chCopyFr.c_str(), "r");
	}
	if (file == nullptr)
    {
		return;
	}

	FILE * scannerFram = fram;
	fram = file;

	CopyFramePart(L"");
	fram = scannerFram;

	fclose(file);
}

void Generator::GenPrefixFromNamespace()
{
	std::wstring nsName = tab->nsName;
	if (nsName.empty())
    {
		return;
	}
	const size_t len = nsName.length();
	size_t startPos = 0;
	do
    {
		size_t curLen = String::IndexOf(nsName, startPos, COCO_CPP_NAMESPACE_SEPARATOR);
		if (curLen == std::wstring::npos)
            curLen = len - startPos;
		std::wstring curNs = String::Create(nsName, startPos, curLen);
		fwprintf(gen, L"%ls_", curNs.c_str());
		startPos = startPos + curLen + 1;
	} 
    while (startPos < len);
}

void Generator::SkipFramePart(std::wstring const & stop)
{
	CopyFramePart(stop, false);
}

void Generator::CopyFramePart(std::wstring const & stop)
{
	CopyFramePart(stop, true);
}

void Generator::CopyFramePart(std::wstring const & stop, bool generateOutput)
{
	wchar_t startCh = 0;
	size_t endOfStopString = 0;
	wchar_t ch = 0;

	if (!stop.empty())
    {
		startCh = stop[0];
		endOfStopString = stop.length() - 1;
	}

	fwscanf(fram, L"%lc", &ch); //	fram.ReadByte();
	while (!feof(fram))
    { // ch != EOF
		if (!stop.empty() && ch == startCh)
        {
			int i = 0;
			do
            {
				if (i == endOfStopString)
                    return; // stop[0..i] found
				fwscanf(fram, L"%lc", &ch);
                i++;
			} 
            while (ch == stop[i]);
			// stop[0..i-1] found; continue with last read character
			if (generateOutput)
            {
				std::wstring subStop = String::Create(stop, 0, i);
				fwprintf(gen, L"%ls", subStop.c_str());
			}
		} 
        else
        {
			if (generateOutput)
                fwprintf(gen, L"%lc", ch);
			fwscanf(fram, L"%lc", &ch);
		}
	}
	if (!stop.empty())
    {
		std::wstring message = String::CreateAppend(L" -- Incomplete or corrupt frame file: ", frameFile);
		errors->Exception(message);
	}
}

} // namespace Coco
