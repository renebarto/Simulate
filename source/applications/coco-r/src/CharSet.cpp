/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

//#include <memory.h>
//#include <stdio.h>
//#include <stdlib.h>
//#include <wchar.h>
#include "CharSet.h"
#include "Scanner.h"

namespace Coco
{

CharSet::CharSet(CharSet const & other)
{
	Range *prev = nullptr;
	for (Range *cur = other.head; cur != nullptr; cur = cur->next)
    {
		Range *r = new Range(cur->from, cur->to);
		if (prev == nullptr) 
            this->head = r; 
        else 
            prev->next = r;
		prev = r;
	}
}

CharSet::CharSet(CharSet && other)
{
    this->head = std::move(other.head);
    other.head = nullptr;
}

CharSet::~CharSet()
{
	Clear();
}
	
CharSet & CharSet::operator = (CharSet const & other)
{
    if (this != &other)
    {
        Clear();
	    Range *prev = nullptr;
	    for (Range *cur = other.head; cur != nullptr; cur = cur->next)
        {
		    Range *r = new Range(cur->from, cur->to);
		    if (prev == nullptr) 
                this->head = r; 
            else 
                prev->next = r;
		    prev = r;
	    }
    }
    return *this;
}

CharSet & CharSet::operator = (CharSet && other)
{
    this->head = std::move(other.head);
    other.head = nullptr;
    return *this;
}

bool CharSet::Get(wchar_t i) const
{
	for (Range *p = head; p != nullptr; p = p->next)
		if (i < p->from) 
            return false;
		else if (i <= p->to) 
            return true; // p.from <= i <= p.to
	return false;
}

void CharSet::Set(wchar_t i)
{
	Range *cur = head, *prev = nullptr;
	while (cur != nullptr && i >= cur->from-1)
    {
		if (i <= cur->to + 1)
        { // (cur.from-1) <= i <= (cur.to+1)
			if (i == cur->from - 1) cur->from--;
			else if (i == cur->to + 1)
            {
				cur->to++;
				Range *next = cur->next;
				if (next != nullptr && cur->to == next->from - 1)
                {
					cur->to = next->to;
					cur->next = next->next;
					delete next;
				};
			}
			return;
		}
		prev = cur; cur = cur->next;
	}
	Range * n = new Range(i, i);
	n->next = cur;
	if (prev == nullptr) 
        head = n; 
    else 
        prev->next = n;
}

CharSet CharSet::Clone() const
{
	CharSet s;
	Range *prev = nullptr;
	for (Range *cur = head; cur != nullptr; cur = cur->next)
    {
		Range *r = new Range(cur->from, cur->to);
		if (prev == nullptr) 
            s.head = r; 
        else 
            prev->next = r;
		prev = r;
	}
	return s;
}

bool CharSet::Equals(CharSet const & s) const
{
	Range *p = head, *q = s.head;
	while (p != nullptr && q != nullptr)
    {
		if (p->from != q->from || p->to != q->to) 
            return false;
		p = p->next; 
        q = q->next;
	}
	return p == q;
}

size_t CharSet::Count() const
{
	size_t n = 0;
	for (Range *p = head; p != nullptr; p = p->next) 
        n += p->to - p->from + 1;
	return n;
}

wchar_t CharSet::First() const
{
	if (head != nullptr) 
        return head->from;
	return -1;
}

void CharSet::Or(CharSet const & s)
{
	for (Range *p = s.head; p != nullptr; p = p->next)
		for (int i = p->from; i <= p->to; i++) 
            Set(i);
}

void CharSet::And(CharSet const & s)
{
	CharSet * newSet = new CharSet();
	Range * p = head;
	while (p != nullptr)
    {
		for (int i = p->from; i <= p->to; i++)
			if (s.Get(i)) 
                newSet->Set(i);
		Range *del = p;
		p = p->next;
		delete del;
	}
	head = newSet->head;
	newSet->head = nullptr;
	delete newSet;
}

void CharSet::Subtract(CharSet const & s)
{
	CharSet * newSet = new CharSet();
	Range * p = head;
	while (p != nullptr)
    {
		for (int i = p->from; i <= p->to; i++)
			if (!s.Get(i)) 
                newSet->Set(i);
		Range *del = p;
		p = p->next;
		delete del;
	}
	head = newSet->head;
	newSet->head = nullptr;
	delete newSet;
}

bool CharSet::Includes(CharSet const & s) const
{
	for (Range *p = s.head; p != nullptr; p = p->next)
		for (int i = p->from; i <= p->to; i++)
			if (!Get(i)) 
                return false;
	return true;
}

bool CharSet::Overlaps(CharSet const & s) const
{
	for (Range *p = s.head; p != nullptr; p = p->next)
		for (int i = p->from; i <= p->to; i++)
			if (Get(i)) 
                return true;
	return false;
}

void CharSet::Clear()
{
	while (head != nullptr)
    {
		Range *del = head;
		head = head->next;
		delete del;
	}
}

void CharSet::Fill()
{
	Clear();
	head = new Range(0, COCO_WCHAR_MAX);
}

} // namespace Coco
