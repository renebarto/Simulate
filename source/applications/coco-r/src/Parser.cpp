/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

#include <iostream>
#include <sstream>
#include <wchar.h>
#include "Parser.h"
#include "Scanner.h"

namespace Coco
{

void Parser::SyntaxError(TokenType tokenType)
{
    if (errDist >= minErrDist) 
        errors->SyntaxError(la->line, la->col, tokenType);
    errDist = 0;
}

void Parser::SemanticError(std::wstring const & msg)
{
    if (errDist >= minErrDist) 
        errors->Error(t->line, t->col, msg);
    errDist = 0;
}

void Parser::Get()
{
    for (;;)
    {
        t = la;
        la = scanner->Scan();
        TokenType laToken = TokenType(la->kind);
        if (laToken <= TokenType::MaxT)
        {
            ++errDist; 
            break;
        }
        if (laToken == TokenType::DDTSym)
        {
            tab->SetDDT(la->val); 
        }
        if (laToken == TokenType::OptionSym)
        {
            tab->SetOption(la->val); 
        }

        if (dummyToken != t)
        {
            dummyToken->kind = t->kind;
            dummyToken->pos = t->pos;
            dummyToken->col = t->col;
            dummyToken->line = t->line;
            dummyToken->next = nullptr;
            dummyToken->val = t->val;
            t = dummyToken;
        }
        la = t;
    }
}

void Parser::Expect(TokenType tokenType)
{
    if (TokenType(la->kind) == tokenType) 
        Get(); 
    else 
        SyntaxError(tokenType);
}

void Parser::ExpectWeak(TokenType tokenType, TokenType follow)
{
    if (TokenType(la->kind) == tokenType) 
        Get();
    else
    {
        SyntaxError(tokenType);
        while (!StartOf(follow)) 
            Get();
    }
}

bool Parser::WeakSeparator(TokenType tokenType, TokenType syFol, TokenType repFol)
{
    if (TokenType(la->kind) == tokenType)
    {
        Get(); 
        return true;
    }
    else if (StartOf(repFol)) 
        return false;
    else
    {
        SyntaxError(tokenType);
        while (!(StartOf(syFol) || StartOf(repFol) || StartOf(TokenType::_EOF)))
            Get();
        return StartOf(syFol);
    }
}

void Parser::Coco()
{
    Symbol *sym; 
    Graph *g, *g1, *g2; 
    wchar_t* gramName = nullptr; 
    CharSet s; 
    size_t beg = la->pos; 
    size_t line = la->line; 
    while (StartOf(TokenType::Identifier))
    {
        Get();
    }
    if (la->pos != beg)
    {
        pgen->usingPos = new Position(beg, t->pos + wcslen(t->val), 0, line);
    }
        
    Expect(TokenType::COMPILER);
    genScanner = true; 
    tab->ignored = {};
    Expect(TokenType::Identifier);
    gramName = t->val;
    beg = la->pos;
    line = la->line;
        
    while (StartOf(TokenType::Number))
    {
        Get();
    }
    tab->semDeclPos = new Position(beg, la->pos, 0, line); 
    if (TokenType(la->kind) == TokenType::IGNORECASE)
    {
        Get();
        dfa->ignoreCase = true; 
    }
    if (TokenType(la->kind) == TokenType::CHARACTERS)
    {
        Get();
        while (TokenType(la->kind) == TokenType::Identifier)
            SetDecl();
    }
    if (TokenType(la->kind) == TokenType::TOKENS)
    {
        Get();
        while (TokenType(la->kind) == TokenType::Identifier || TokenType(la->kind) == TokenType::String || TokenType(la->kind) == TokenType::Char)
            TokenDecl(Node::t);
    }
    if (TokenType(la->kind) == TokenType::PRAGMAS)
    {
        Get();
        while (TokenType(la->kind) == TokenType::Identifier || TokenType(la->kind) == TokenType::String || TokenType(la->kind) == TokenType::Char)
            TokenDecl(Node::pr);
    }
    while (TokenType(la->kind) == TokenType::COMMENTS)
    {
        Get();
        bool nested = false; 
        Expect(TokenType::FROM);
        TokenExpr(g1);
        Expect(TokenType::TO);
        TokenExpr(g2);
        if (TokenType(la->kind) == TokenType::NESTED)
        {
            Get();
            nested = true; 
        }
        dfa->NewComment(g1->l, g2->l, nested); 
    }
    while (TokenType(la->kind) == TokenType::_IGNORE)
    {
        Get();
        Set(s);
        tab->ignored |= s; 
    }
    while (!(TokenType(la->kind) == TokenType::_EOF || TokenType(la->kind) == TokenType::PRODUCTIONS))
    {
        SyntaxError(TokenType::DDTSym); 
        Get();
    }
    Expect(TokenType::PRODUCTIONS);
    if (genScanner) 
        dfa->MakeDeterministic();
    tab->DeleteNodes();
        
    while (TokenType(la->kind) == TokenType::Identifier)
    {
        Get();
        sym = tab->FindSym(t->val);
        bool undef = (sym == nullptr);
        if (undef) 
            sym = tab->NewSym(Node::nt, t->val, t->line);
        else
        {
            if (sym->typ == Node::nt)
            {
                if (sym->graph != nullptr) 
                    SemanticError(L"name declared twice");
            } 
            else 
                SemanticError(L"this symbol kind not allowed on left side of production");
            sym->line = t->line;
        }
        bool noAttrs = (sym->attrPos == nullptr);
        sym->attrPos = nullptr;
            
        if (TokenType(la->kind) == TokenType::AngleBracketOpen /* "<" */ || TokenType(la->kind) == TokenType::AngleBracketOpenDot /* "<." */)
            AttrDecl(sym);
        if (!undef)
            if (noAttrs != (sym->attrPos == nullptr))
                SemanticError(L"attribute mismatch between declaration and use of this symbol");
            
        if (TokenType(la->kind) == TokenType::ParenthesisOpenDot /* "(." */)
            SemText(sym->semPos);
        ExpectWeak(TokenType::Equals /* "=" */, TokenType::String);
        Expression(g);
        sym->graph = g->l;
        tab->Finish(g);
            
        ExpectWeak(TokenType::Dot /* "." */, TokenType::BadString);
    }
    Expect(TokenType::END);
    Expect(TokenType::Identifier);
    if (!String::Equal(gramName, t->val))
        SemanticError(L"name does not match grammar name");
    tab->gramSy = tab->FindSym(gramName);
    if (tab->gramSy == nullptr)
        SemanticError(L"missing production for grammar name");
    else
    {
        sym = tab->gramSy;
        if (sym->attrPos != nullptr)
            SemanticError(L"grammar symbol must not have attributes");
    }
    tab->noSym = tab->NewSym(Node::t, L"???", 0); // noSym gets highest number
    tab->SetupAnys();
    tab->RenumberPragmas();
    if (tab->ddt[2]) 
        tab->PrintNodes();
    if (errors->count == 0)
    {
        wprintf(L"checking\n");
        tab->CompSymbolSets();
        if (tab->ddt[7]) 
            tab->XRef();
        if (tab->GrammarOk())
        {
            wprintf(L"parser");
            pgen->WriteParser();
            if (genScanner)
            {
                wprintf(L" + scanner");
                dfa->WriteScanner();
                if (tab->ddt[0])
                    dfa->PrintStates();
            }
            wprintf(L" generated\n");
            if (tab->ddt[8]) 
                pgen->WriteStatistics();
        }
    }
    if (tab->ddt[6])
        tab->PrintSymbolTable();
        
    Expect(TokenType::Dot /* "." */);
}

void Parser::SetDecl()
{
    CharSet s; 
    Expect(TokenType::Identifier);
    std::wstring name = t->val;
    CharClass * c = tab->FindCharClass(name);
    if (c != nullptr) 
        SemanticError(L"name declared twice");
        
    Expect(TokenType::Equals /* "=" */);
    Set(s);
    if (s.Count() == 0) 
        SemanticError(L"character set must not be empty");
    tab->NewCharClass(name, s);
        
    Expect(TokenType::Dot /* "." */);
}

void Parser::TokenDecl(int typ)
{
    std::wstring name;
    int kind; 
    Symbol *sym; 
    Graph *g; 
    Sym(name, kind);
    sym = tab->FindSym(name);
    if (sym != nullptr) 
        SemanticError(L"name declared twice");
    else
    {
        sym = tab->NewSym(typ, name, t->line);
        sym->tokenKind = Symbol::fixedToken;
    }
    tokenString = {};
        
    while (!(StartOf(TokenType::Char)))
    {
        SyntaxError(TokenType::OptionSym); 
        Get();
    }
    if (TokenType(la->kind) == TokenType::Equals /* "=" */)
    {
        Get();
        TokenExpr(g);
        Expect(TokenType::Dot /* "." */);
        if (kind == str) 
            SemanticError(L"a literal must not be declared with a structure");
        tab->Finish(g);
        if (tokenString.empty() || String::Equal(tokenString, noString))
            dfa->ConvertToStates(g->l, sym);
        else
        { // TokenExpr is a single string
            if ((*(tab->literals))[tokenString] != nullptr)
                SemanticError(L"token string declared twice");
            tab->literals->Set(tokenString, sym);
            dfa->MatchLiteral(tokenString, sym);
        }
            
    } 
    else if (StartOf(TokenType::COMPILER))
    {
        if (kind == id) 
            genScanner = false;
        else 
            dfa->MatchLiteral(sym->name, sym);
            
    } 
    else 
        SyntaxError(TokenType::InvalidTokenDecl);
    if (TokenType(la->kind) == TokenType::ParenthesisOpenDot /* "(." */)
    {
        SemText(sym->semPos);
        if (typ != Node::pr) 
            SemanticError(L"semantic action not allowed here"); 
    }
}

void Parser::TokenExpr(Graph *& g)
{
    Graph * g2; 
    TokenTerm(g);
    bool first = true; 
    while (WeakSeparator(TokenType::Pipe /* "|" */, TokenType::CHARACTERS, TokenType::IGNORECASE))
    {
        TokenTerm(g2);
        if (first)
        { 
            tab->MakeFirstAlt(g); 
            first = false;
        }
        tab->MakeAlternative(g, g2);
    }
}

void Parser::Set(CharSet & s)
{
    CharSet s2; 
    SimSet(s);
    while (TokenType(la->kind) == TokenType::Plus /* "+" */ || TokenType(la->kind) == TokenType::Minus /* "-" */)
    {
        if (TokenType(la->kind) == TokenType::Plus /* "+" */)
        {
            Get();
            SimSet(s2);
            s |= s2; 
        }
        else
        {
            Get();
            SimSet(s2);
            s -= s2; 
        }
    }
}

void Parser::AttrDecl(Symbol * sym)
{
    if (TokenType(la->kind) == TokenType::AngleBracketOpen /* "<" */)
    {
        Get();
        size_t beg = la->pos; 
        size_t col = la->col; 
        size_t line = la->line; 
        while (StartOf(TokenType::TOKENS))
        {
            if (StartOf(TokenType::PRAGMAS))
                Get();
            else
            {
                Get();
                SemanticError(L"bad string in attributes"); 
            }
        }
        Expect(TokenType::AngleBracketClose /* ">" */);
        if (t->pos > beg)
            sym->attrPos = new Position(beg, t->pos, col, line); 
    } 
    else if (TokenType(la->kind) == TokenType::AngleBracketOpenDot /* "<." */)
    {
        Get();
        size_t beg = la->pos; 
        size_t col = la->col; 
        size_t line = la->line; 
        while (StartOf(TokenType::COMMENTS))
        {
            if (StartOf(TokenType::FROM))
                Get();
            else
            {
                Get();
                SemanticError(L"bad string in attributes"); 
            }
        }
        Expect(TokenType::AngleBracketCloseDot /* ".>" */);
        if (t->pos > beg)
            sym->attrPos = new Position(beg, t->pos, col, line); 
    } 
    else 
        SyntaxError(TokenType::InvalidAttrDecl);
}

void Parser::SemText(Position *& pos)
{
    Expect(TokenType::ParenthesisOpenDot /* "(." */);
    size_t beg = la->pos; 
    size_t col = la->col; 
    size_t line = t->line; 
    while (StartOf(TokenType::TO))
    {
        if (StartOf(TokenType::NESTED))
            Get();
        else if (TokenType(la->kind) == TokenType::BadString)
        {
            Get();
            SemanticError(L"bad string in semantic action"); 
        }
        else
        {
            Get();
            SemanticError(L"missing end of previous semantic action"); 
        }
    }
    Expect(TokenType::ParenthesisCloseDot /* ".)" */);
    pos = new Position(beg, t->pos, col, line); 
}

void Parser::Expression(Graph *& g)
{
    Graph *g2; 
    Term(g);
    bool first = true; 
    while (WeakSeparator(TokenType::Pipe /* "|" */, TokenType::PRODUCTIONS, TokenType::_IGNORE))
    {
        Term(g2);
        if (first)
        {
            tab->MakeFirstAlt(g); 
            first = false;
        }
        tab->MakeAlternative(g, g2);
    }
}

void Parser::SimSet(CharSet & s)
{
    int n1, n2; 
    s = {};
    if (TokenType(la->kind) == TokenType::Identifier)
    {
        Get();
        CharClass * c = tab->FindCharClass(t->val);
        if (c == nullptr) 
            SemanticError(L"undefined name"); 
        else 
            s |= c->GetCharSet();
    } 
    else if (TokenType(la->kind) == TokenType::String)
    {
        Get();
        std::wstring subName2 = String::Create(t->val, 1, wcslen(t->val)-2);
        std::wstring name = tab->Unescape(subName2);
        wchar_t ch;
        size_t len = name.length();
        for(size_t i = 0; i < len; i++)
        {
            ch = name[i];
            if (dfa->ignoreCase)
            {
                if ((L'A' <= ch) && (ch <= L'Z')) 
                    ch = ch - (L'A' - L'a'); // ch.ToLower()
            }
            s.Set(ch);
        }
    } 
    else if (TokenType(la->kind) == TokenType::Char)
    {
        Char(n1);
        s.Set(n1); 
        if (TokenType(la->kind) == TokenType::DotDot /* ".." */)
        {
            Get();
            Char(n2);
            for (int i = n1; i <= n2; i++) 
                s.Set(i); 
        }
    } 
    else if (TokenType(la->kind) == TokenType::ANY)
    {
        Get();
        s = {};
        s.Fill(); 
    } 
    else 
        SyntaxError(TokenType::InvalidSimSet);
}

void Parser::Char(int & n)
{
    Expect(TokenType::Char);
    n = 0;
    std::wstring subName = String::Create(t->val, 1, wcslen(t->val)-2);
    std::wstring name = tab->Unescape(subName);
        
    // "<= 1" instead of "== 1" to allow the escape sequence '\0' in c++
    if (name.length() <= 1)
        n = name[0];
    else
        SemanticError(L"unacceptable character value");
    if (dfa->ignoreCase && (((wchar_t) n) >= 'A') && (((wchar_t) n) <= 'Z')) 
        n += 32;
}

void Parser::Sym(std::wstring & name, int & kind)
{
    name = L"???"; 
    kind = id; 
    if (TokenType(la->kind) == TokenType::Identifier)
    {
        Get();
        kind = id;
        name = t->val; 
    } 
    else if (TokenType(la->kind) == TokenType::String || TokenType(la->kind) == TokenType::Char)
    {
        if (TokenType(la->kind) == TokenType::String)
        {
            Get();
            name = t->val; 
        } 
        else
        {
            Get();
            std::wstring subName = String::Create(t->val, 1, wcslen(t->val)-2);
            name = String::CreateAppend(L"\"", subName);
            String::Merge(name, L"\""); 
        }
        kind = str;
        if (dfa->ignoreCase)
        {
            name = String::CreateLower(name);
        }
        if (String::IndexOf(name, ' ') != std::wstring::npos)
            SemanticError(L"literal tokens must not contain blanks"); 
    }
    else 
        SyntaxError(TokenType::InvalidSym);
}

void Parser::Term(Graph *& g)
{
    Graph *g2; 
    Node *rslv = nullptr; 
    g = nullptr; 
    if (StartOf(TokenType::Equals))
    {
        if (TokenType(la->kind) == TokenType::IF)
        {
            rslv = tab->NewNode(Node::rslv, nullptr, la->line); 
            Resolver(rslv->pos);
            g = new Graph(rslv); 
        }
        Factor(g2);
        if (rslv != nullptr) 
            tab->MakeSequence(g, g2);
        else
            g = g2; 
        while (StartOf(TokenType::Dot))
        {
            Factor(g2);
            tab->MakeSequence(g, g2); 
        }
    } 
    else if (StartOf(TokenType::END))
    {
        g = new Graph(tab->NewNode(Node::eps, nullptr, 0)); 
    }
    else
        SyntaxError(TokenType::InvalidTerm);
    if (g == nullptr) // invalid start of Term
        g = new Graph(tab->NewNode(Node::eps, nullptr, 0)); 
}

void Parser::Resolver(Position *& pos)
{
    Expect(TokenType::IF);
    Expect(TokenType::ParenthesisOpen /* "(" */);
    size_t beg = la->pos; 
    size_t col = la->col; 
    size_t line = la->line; 
    Condition();
    pos = new Position(beg, t->pos, col, line); 
}

void Parser::Factor(Graph *& g)
{
    std::wstring name;
    int kind; 
    Position *pos; 
    bool weak = false; 
    g = nullptr;
        
    switch (TokenType(la->kind))
    {
    case TokenType::Identifier: 
    case TokenType::String: 
    case TokenType::Char: 
    case TokenType::WEAK:
        {
            if (TokenType(la->kind) == TokenType::WEAK)
            {
                Get();
                weak = true; 
            }
            Sym(name, kind);
            Symbol *sym = tab->FindSym(name);
            if (sym == nullptr && kind == str)
                sym = (Symbol*)((*(tab->literals))[name]);
            bool undef = (sym == nullptr);
            if (undef)
            {
                if (kind == id)
                    sym = tab->NewSym(Node::nt, name, 0);  // forward nt
                else if (genScanner)
                { 
                    sym = tab->NewSym(Node::t, name, t->line);
                    dfa->MatchLiteral(sym->name, sym);
                } 
                else
                {  // undefined string in production
                    SemanticError(L"undefined string in production");
                    sym = tab->eofSy;  // dummy
                }
            }
            int typ = sym->typ;
            if (typ != Node::t && typ != Node::nt)
                SemanticError(L"this symbol kind is not allowed in a production");
            if (weak)
            {
                if (typ == Node::t)
                    typ = Node::wt;
                else 
                    SemanticError(L"only terminals may be weak");
            }
            Node *p = tab->NewNode(typ, sym, t->line);
            g = new Graph(p);
            
            if (TokenType(la->kind) == TokenType::AngleBracketOpen /* "<" */ || TokenType(la->kind) == TokenType::AngleBracketOpenDot /* "<." */)
            {
                Attribs(p);
                if (kind != id) 
                    SemanticError(L"a literal must not have attributes"); 
            }
            if (undef)
                sym->attrPos = p->pos;  // dummy
            else if ((p->pos == nullptr) != (sym->attrPos == nullptr))
                SemanticError(L"attribute mismatch between declaration and use of this symbol");
            
            break;
        }
    case TokenType::ParenthesisOpen /* "(" */:
        {
            Get();
            Expression(g);
            Expect(TokenType::ParenthesisClose /* ")" */);
            break;
        }
    case TokenType::SquareBracketOpen /* "[" */:
        {
            Get();
            Expression(g);
            Expect(TokenType::SquareBracketClose /* "]" */);
            tab->MakeOption(g); 
            break;
        }
    case TokenType::CurlyBraceOpen /* "{" */:
        {
            Get();
            Expression(g);
            Expect(TokenType::CurlyBraceClose /* "}" */);
            tab->MakeIteration(g); 
            break;
        }
    case TokenType::ParenthesisOpenDot /* "(." */:
        {
            SemText(pos);
            Node *p = tab->NewNode(Node::sem, nullptr, 0);
            p->pos = pos;
            g = new Graph(p);			 
            break;
        }
    case TokenType::ANY:
        {
            Get();
            Node *p = tab->NewNode(Node::any, nullptr, 0);  // p.set is set in tab->SetupAnys
            g = new Graph(p);			
            break;
        }
    case TokenType::SYNC:
        {
            Get();
            Node *p = tab->NewNode(Node::sync, nullptr, 0);
            g = new Graph(p);			
            break;
        }
    default: SyntaxError(TokenType::InvalidFactor); 
        break;
    }
    if (g == nullptr) // invalid start of Factor
        g = new Graph(tab->NewNode(Node::eps, nullptr, 0));
}

void Parser::Attribs(Node *p)
{
    if (TokenType(la->kind) == TokenType::AngleBracketOpen /* "<" */)
    {
        Get();
        size_t beg = la->pos; 
        size_t col = la->col; 
        size_t line = la->line; 
        while (StartOf(TokenType::TOKENS))
        {
            if (StartOf(TokenType::PRAGMAS))
            {
                Get();
            }
            else
            {
                Get();
                SemanticError(L"bad string in attributes"); 
            }
        }
        Expect(TokenType::AngleBracketClose /* ">" */);
        if (t->pos > beg) 
            p->pos = new Position(beg, t->pos, col, line); 
    } 
    else if (TokenType(la->kind) == TokenType::AngleBracketOpenDot /* "<." */)
    {
        Get();
        size_t beg = la->pos; 
        size_t col = la->col; 
        size_t line = la->line; 
        while (StartOf(TokenType::COMMENTS))
        {
            if (StartOf(TokenType::FROM))
            {
                Get();
            }
            else
            {
                Get();
                SemanticError(L"bad string in attributes"); 
            }
        }
        Expect(TokenType::AngleBracketCloseDot /* ".>" */);
        if (t->pos > beg) 
            p->pos = new Position(beg, t->pos, col, line); 
    } 
    else 
        SyntaxError(TokenType::InvalidAttribs);
}

void Parser::Condition()
{
    while (StartOf(TokenType::Plus))
    {
        if (TokenType(la->kind) == TokenType::ParenthesisOpen /* "(" */)
        {
            Get();
            Condition();
        }
        else
            Get();
    }
    Expect(TokenType::ParenthesisClose /* ")" */);
}

void Parser::TokenTerm(Graph *& g)
{
    Graph *g2; 
    TokenFactor(g);
    while (StartOf(TokenType::CHARACTERS))
    {
        TokenFactor(g2);
        tab->MakeSequence(g, g2); 
    }
    if (TokenType(la->kind) == TokenType::CONTEXT)
    {
        Get();
        Expect(TokenType::ParenthesisOpen /* "(" */);
        TokenExpr(g2);
        tab->SetContextTrans(g2->l); dfa->hasCtxMoves = true;
        tab->MakeSequence(g, g2); 
        Expect(TokenType::ParenthesisClose /* ")" */);
    }
}

void Parser::TokenFactor(Graph *& g)
{
    std::wstring name;
    int kind; 
    g = nullptr; 
    if (TokenType(la->kind) == TokenType::Identifier || TokenType(la->kind) == TokenType::String || TokenType(la->kind) == TokenType::Char)
    {
        Sym(name, kind);
        if (kind == id)
        {
            CharClass * c = tab->FindCharClass(name);
            if (c == nullptr)
            {
                SemanticError(L"undefined name");
                c = tab->NewCharClass(name, CharSet());
            }
            Node *p = tab->NewNode(Node::clas, nullptr, 0); 
            p->val = wchar_t(c->GetClassID());
            g = new Graph(p);
            tokenString = noString;
        } 
        else
        { // str
            g = tab->StrToGraph(name);
            if (tokenString.empty()) 
                tokenString = name;
            else 
                tokenString = noString;
        }
    } 
    else if (TokenType(la->kind) == TokenType::ParenthesisOpen /* "(" */)
    {
        Get();
        TokenExpr(g);
        Expect(TokenType::ParenthesisClose /* ")" */);
    } 
    else if (TokenType(la->kind) == TokenType::SquareBracketOpen /* "[" */)
    {
        Get();
        TokenExpr(g);
        Expect(TokenType::SquareBracketClose /* "]" */);
        tab->MakeOption(g); 
        tokenString = noString; 
    } 
    else if (TokenType(la->kind) == TokenType::CurlyBraceOpen /* "{" */) 
    {
        Get();
        TokenExpr(g);
        Expect(TokenType::CurlyBraceClose /* "}" */);
        tab->MakeIteration(g); 
        tokenString = noString; 
    } 
    else 
        SyntaxError(TokenType::InvalidTokenFactor);
    if (g == nullptr) // invalid start of TokenFactor
        g = new Graph(tab->NewNode(Node::eps, nullptr, 0)); 
}


// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer
{
    template<typename U, void (U::*)() = &U::Init>
    struct ExistsIfInitIsDefinedMarker{};

    struct InitIsMissingType
    {
        char dummy1;
    };
    
    struct InitExistsType
    {
        char dummy1; char dummy2;
    };

    // exists always
    template<typename U>
    static InitIsMissingType is_here(...);

    // exist only if ExistsIfInitIsDefinedMarker is defined
    template<typename U>
    static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

    enum { InitExists = (sizeof(is_here<T>(nullptr)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer
{
    template<typename U, void (U::*)() = &U::Destroy>
    struct ExistsIfDestroyIsDefinedMarker{};

    struct DestroyIsMissingType
    {
        char dummy1;
    };
    
    struct DestroyExistsType
    {
        char dummy1; char dummy2;
    };

    // exists always
    template<typename U>
    static DestroyIsMissingType is_here(...);

    // exist only if ExistsIfDestroyIsDefinedMarker is defined
    template<typename U>
    static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

    enum { DestroyExists = (sizeof(is_here<T>(nullptr)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller
{
    static void CallInit(T *t)
    {
        // nothing to do
    }
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true>
{
    static void CallInit(T *t)
    {
        t->Init();
    }
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller 
{
    static void CallDestroy(T *t)
    {
        // nothing to do
    }
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true>
{
    static void CallDestroy(T *t)
    {
        t->Destroy();
    }
};

void Parser::Parse()
{
    t = nullptr;
    la = dummyToken = new Token();
    la->val = _wcsdup(L"Dummy Token");
    Get();
    Coco();
    Expect(TokenType::_EOF);
}

Parser::Parser(Scanner * scanner)
{
    ParserInitCaller<Parser>::CallInit(this);
    dummyToken = nullptr;
    t = la = nullptr;
    minErrDist = 2;
    errDist = minErrDist;
    this->scanner = scanner;
    errors = new Errors(std::wcout);
}

bool Parser::StartOf(TokenType tokenType)
{
    const bool T = true;
    const bool x = false;

    static bool set[21][43] =
    {
        {T,T,x,T, x,T,x,x, x,x,T,T, x,x,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x},
        {x,T,T,T, T,T,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},
        {x,T,T,T, T,T,T,x, x,x,x,x, T,T,T,x, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},
        {T,T,x,T, x,T,x,x, x,x,T,T, x,x,x,T, T,T,T,x, x,x,x,T, x,x,x,x, T,T,T,x, T,x,T,x, T,T,x,T, x,x,x},
        {T,T,x,T, x,T,x,x, x,x,T,T, x,x,x,T, T,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x},
        {T,T,x,T, x,T,x,x, x,x,T,T, x,x,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x},
        {x,T,x,T, x,T,x,x, x,x,T,T, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x},
        {x,x,x,x, x,x,x,x, x,x,x,T, x,T,T,T, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,T, x,x,x,x, x,x,x},
        {x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,T,x, x,x,x,x, x,x,x},
        {x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},
        {x,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},
        {x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},
        {x,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x},
        {x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, x,T,x},
        {x,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, x,T,x},
        {x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,T, x,x,x,x, x,x,x},
        {x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,x, T,T,T,T, T,T,T,T, T,T,x,T, x,x,x},
        {x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,T,T,x, T,x,T,x, T,T,x,T, x,x,x},
        {x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,T,T,x, T,x,T,x, T,x,x,T, x,x,x},
        {x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,T, x,x,x,x, x,x,x},
        {x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,x}
    };

    return set[int(tokenType)][la->kind];
}

Parser::~Parser()
{
    ParserDestroyCaller<Parser>::CallDestroy(this);
    delete errors;
    delete dummyToken;
}

Errors::Errors(std::wostream & stream)
    : stream(stream)
    , count()
{
}

void Errors::SyntaxError(size_t line, size_t col, Parser::TokenType tokenType)
{
    std::wstring s;
    switch (tokenType)
    {
    case Parser::TokenType::_EOF:                   s = L"EOF expected"; break;
    case Parser::TokenType::Identifier:             s = L"Identifier expected"; break;
    case Parser::TokenType::Number:                 s = L"Number expected"; break;
    case Parser::TokenType::String:                 s = L"String expected"; break;
    case Parser::TokenType::BadString:              s = L"BadString expected"; break;
    case Parser::TokenType::Char:                   s = L"Char expected"; break;
    case Parser::TokenType::COMPILER:               s = L"\"COMPILER\" expected"; break;
    case Parser::TokenType::IGNORECASE:             s = L"\"IGNORECASE\" expected"; break;
    case Parser::TokenType::CHARACTERS:             s = L"\"CHARACTERS\" expected"; break;
    case Parser::TokenType::TOKENS:                 s = L"\"TOKENS\" expected"; break;
    case Parser::TokenType::PRAGMAS:                s = L"\"PRAGMAS\" expected"; break;
    case Parser::TokenType::COMMENTS:               s = L"\"COMMENTS\" expected"; break;
    case Parser::TokenType::FROM:                   s = L"\"FROM\" expected"; break;
    case Parser::TokenType::TO:                     s = L"\"TO\" expected"; break;
    case Parser::TokenType::NESTED:                 s = L"\"NESTED\" expected"; break;
    case Parser::TokenType::_IGNORE:                s = L"\"IGNORE\" expected"; break;
    case Parser::TokenType::PRODUCTIONS:            s = L"\"PRODUCTIONS\" expected"; break;
    case Parser::TokenType::Equals:                 s = L"\"=\" expected"; break;
    case Parser::TokenType::Dot:                    s = L"\".\" expected"; break;
    case Parser::TokenType::END:                    s = L"\"END\" expected"; break;
    case Parser::TokenType::Plus:                   s = L"\"+\" expected"; break;
    case Parser::TokenType::Minus:                  s = L"\"-\" expected"; break;
    case Parser::TokenType::DotDot:                 s = L"\"..\" expected"; break;
    case Parser::TokenType::ANY:                    s = L"\"ANY\" expected"; break;
    case Parser::TokenType::AngleBracketOpen:       s = L"\"<\" expected"; break;
    case Parser::TokenType::AngleBracketClose:      s = L"\">\" expected"; break;
    case Parser::TokenType::AngleBracketOpenDot:    s = L"\"<.\" expected"; break;
    case Parser::TokenType::AngleBracketCloseDot:   s = L"\".>\" expected"; break;
    case Parser::TokenType::Pipe:                   s = L"\"|\" expected"; break;
    case Parser::TokenType::WEAK:                   s = L"\"WEAK\" expected"; break;
    case Parser::TokenType::ParenthesisOpen:        s = L"\"(\" expected"; break;
    case Parser::TokenType::ParenthesisClose:       s = L"\")\" expected"; break;
    case Parser::TokenType::SquareBracketOpen:      s = L"\"[\" expected"; break;
    case Parser::TokenType::SquareBracketClose:     s = L"\"]\" expected"; break;
    case Parser::TokenType::CurlyBraceOpen:         s = L"\"{\" expected"; break;
    case Parser::TokenType::CurlyBraceClose:        s = L"\"}\" expected"; break;
    case Parser::TokenType::SYNC:                   s = L"\"SYNC\" expected"; break;
    case Parser::TokenType::IF:                     s = L"\"IF\" expected"; break;
    case Parser::TokenType::CONTEXT:                s = L"\"CONTEXT\" expected"; break;
    case Parser::TokenType::ParenthesisOpenDot:     s = L"\"(.\" expected"; break;
    case Parser::TokenType::ParenthesisCloseDot:    s = L"\".)\" expected"; break;
    case Parser::TokenType::MaxT:                   s = L"??? expected"; break;
    case Parser::TokenType::DDTSym:                 s = L"This symbol not expected in Coco"; break;
    case Parser::TokenType::OptionSym:              s = L"This symbol not expected in TokenDecl"; break;
    case Parser::TokenType::InvalidTokenDecl:       s = L"Invalid TokenDecl"; break;
    case Parser::TokenType::InvalidAttrDecl:        s = L"Invalid AttrDecl"; break;
    case Parser::TokenType::InvalidSimSet:          s = L"Invalid SimSet"; break;
    case Parser::TokenType::InvalidSym:             s = L"Invalid Sym"; break;
    case Parser::TokenType::InvalidTerm:            s = L"Invalid Term"; break;
    case Parser::TokenType::InvalidFactor:          s = L"Invalid Factor"; break;
    case Parser::TokenType::InvalidAttribs:         s = L"Invalid Attribs"; break;
    case Parser::TokenType::InvalidTokenFactor:     s = L"Invalid TokenFactor"; break;

    default:
        {
            std::wostringstream formatStream;
            formatStream << "error " << int(tokenType);
            s = formatStream.str();
        }
        break;
    }
    stream << L"-- line " << line << " col " << col << ": " << s.c_str() << std::endl;
    count++;
}

void Errors::Error(size_t line, size_t col, std::wstring const & s)
{
    stream << L"-- line " << line << " col " << col << ": " << s.c_str() << std::endl;
    count++;
}

void Errors::Warning(size_t line, size_t col, std::wstring const & s)
{
    stream << L"-- line " << line << " col " << col << ": " << s.c_str() << std::endl;
}

void Errors::Warning(std::wstring const & s)
{
    stream << s.c_str() << std::endl;
}

void Errors::Exception(std::wstring const & s)
{
    stream << s.c_str() << std::endl;
    exit(1);
}

void Errors::Exception(std::string const & s)
{
    stream << s.c_str() << std::endl;
    exit(1);
}

} // namespace Coco

